/// Parses ../CHANGELOG.md and generates lib/core/changelog.g.dart
///
/// Run with: dart run tool/generate_changelog.dart
// ignore_for_file: avoid_print
library;

import 'dart:io';

/// Section header patterns mapped to enum names.
const Map<String, String> sectionMap = <String, String>{
  'API changes warning': 'ChangelogSection.apiChanges',
  'Added Features and Improvements': 'ChangelogSection.addedFeatures',
  'Bugfix': 'ChangelogSection.bugfix',
  'Other changes': 'ChangelogSection.otherChanges',
};

/// Try to match a `### ...` header to one of our known sections.
String? matchSection(String line) {
  final String trimmed = line.trim();
  if (!trimmed.startsWith('### ')) {
    return null;
  }
  // Remove leading "### " and trailing ":"
  final String header = trimmed.substring(4).replaceAll(RegExp(r':$'), '');
  for (final MapEntry<String, String> entry in sectionMap.entries) {
    if (header.contains(entry.key)) {
      return entry.value;
    }
  }
  return null;
}

/// Parse a version header line like `## [0.15.1] - 2026-02-03` or
/// `## [Unreleased]`.
({String version, String? date})? parseVersionHeader(String line) {
  final RegExp re = RegExp(
    r'^##\s+\[([^\]]+)\](?:\s*-\s*(\d{4}-\d{2}-\d{2}))?',
  );
  final RegExpMatch? m = re.firstMatch(line.trim());
  if (m == null) {
    return null;
  }
  return (version: m.group(1)!, date: m.group(2));
}

void main() {
  // Resolve paths relative to the current working directory (the app/ root).
  // CHANGELOG.md lives in the parent (repo root) directory.
  final Directory packageRoot = Directory.current;
  final File changelogFile = File('${packageRoot.parent.path}/CHANGELOG.md');
  final File outputFile = File('${packageRoot.path}/lib/core/changelog.g.dart');

  if (!changelogFile.existsSync()) {
    stderr.writeln('ERROR: ${changelogFile.path} not found.');
    exit(1);
  }

  final List<String> lines = changelogFile.readAsLinesSync();

  // ── Parse ──────────────────────────────────────────────────────────────

  // Each entry: version, date?, sections (enum->bullet list)
  final List<
    ({String version, String? date, Map<String, List<String>> sections})
  >
  entries =
      <({String version, String? date, Map<String, List<String>> sections})>[];

  String? currentSection;
  Map<String, List<String>>? currentSections;
  bool insideEntries = false;
  bool trailingLinks = false;
  final List<({int lineNumber, String text})> unparsedLines =
      <({int lineNumber, String text})>[];

  for (int i = 0; i < lines.length; i++) {
    final String line = lines[i];

    // ── version header ──
    final versionMatch = parseVersionHeader(line);
    if (versionMatch != null) {
      insideEntries = true;
      trailingLinks = false;
      currentSections = <String, List<String>>{};
      currentSection = null;
      entries.add((
        version: versionMatch.version,
        date: versionMatch.date,
        sections: currentSections,
      ));
      continue;
    }

    // Skip everything before the first version header.
    if (!insideEntries) {
      continue;
    }

    // ── trailing link references like [0.15.1]: https://... ──
    final String trimmed = line.trim();
    if (trimmed.startsWith('[') && trimmed.contains(']: ')) {
      trailingLinks = true;
      continue;
    }
    if (trailingLinks) {
      // Once we're in the trailing links block, skip remaining lines.
      continue;
    }

    // ── section header ──
    final String? sec = matchSection(line);
    if (sec != null) {
      currentSection = sec;
      currentSections?.putIfAbsent(sec, () => <String>[]);
      continue;
    }

    // ── bullet item ──
    if (trimmed.startsWith('- ') &&
        currentSection != null &&
        currentSections != null) {
      currentSections[currentSection]!.add(trimmed.substring(2));
      continue;
    }

    // ── continuation of a multi-line bullet ──
    if (trimmed.isNotEmpty &&
        !trimmed.startsWith('#') &&
        !trimmed.startsWith('[') &&
        currentSection != null &&
        currentSections != null &&
        currentSections[currentSection]!.isNotEmpty) {
      // Append to the previous bullet.
      currentSections[currentSection]!.last += ' $trimmed';
      continue;
    }

    // ── empty lines are expected separators ──
    if (trimmed.isEmpty) {
      continue;
    }

    // ── unparsed line ──
    unparsedLines.add((lineNumber: i + 1, text: line));
  }

  // ── Generate Dart source ───────────────────────────────────────────────

  final StringBuffer buf = StringBuffer()
    ..writeln('// GENERATED CODE - DO NOT MODIFY BY HAND')
    ..writeln('// Generated by: dart run tool/generate_changelog.dart')
    ..writeln('// ignore_for_file: public_member_api_docs')
    ..writeln('// ignore_for_file: lines_longer_than_80_chars')
    ..writeln()
    ..writeln("part of 'changelog.dart';")
    ..writeln()
    ..writeln('/// The full parsed changelog from CHANGELOG.md.')
    ..writeln('const Changelog changelog = Changelog(<ChangelogEntry>[');

  for (final entry in entries) {
    buf.writeln('  ChangelogEntry(');
    buf.writeln("    version: '${_escape(entry.version)}',");
    if (entry.date != null) {
      buf.writeln("    dateString: '${entry.date}',");
    }
    if (entry.sections.isNotEmpty) {
      buf.writeln('    sections: <ChangelogSection, List<String>>{');
      for (final MapEntry<String, List<String>> sec in entry.sections.entries) {
        buf.writeln('      ${sec.key}: <String>[');
        for (final String item in sec.value) {
          buf.writeln("        '${_escape(item)}',");
        }
        buf.writeln('      ],');
      }
      buf.writeln('    },');
    }
    buf.writeln('  ),');
  }

  buf.writeln(']);');

  outputFile.writeAsStringSync(buf.toString());
  print('Generated ${outputFile.path} with ${entries.length} entries.');

  if (unparsedLines.isNotEmpty) {
    print('');
    print('WARNING: ${unparsedLines.length} line(s) could not be parsed:');
    for (final line in unparsedLines) {
      print('  L${line.lineNumber}: ${line.text}');
    }
  }
}

/// Escape single quotes and backslashes for Dart string literals.
String _escape(String s) => s.replaceAll(r'\', r'\\').replaceAll("'", r"\'");
